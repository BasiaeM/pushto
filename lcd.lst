   1               		.file	"lcd.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	lcdcmd
  12               	lcdcmd:
  13               	.LFB6:
  14               		.file 1 "lcd.c"
   1:lcd.c         **** 
   2:lcd.c         **** #include "lcd.h"
   3:lcd.c         **** #include <util/delay.h>
   4:lcd.c         **** 
   5:lcd.c         **** void lcdcmd(unsigned char Dane)
   6:lcd.c         **** {
  15               		.loc 1 6 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
   7:lcd.c         **** 
   8:lcd.c         **** LCD_PORT &= ~RS; //wysy≈Çanie polecenia
  22               		.loc 1 8 0
  23 0000 D898      		cbi 0x1b,0
   9:lcd.c         **** LCD_PORT  &=~EN;
  24               		.loc 1 9 0
  25 0002 DA98      		cbi 0x1b,2
  10:lcd.c         **** LCD_PORT &=~RW;
  26               		.loc 1 10 0
  27 0004 D998      		cbi 0x1b,1
  11:lcd.c         **** LCD_PORT &= 0x0f;
  28               		.loc 1 11 0
  29 0006 9BB3      		in r25,0x1b
  30 0008 9F70      		andi r25,lo8(15)
  31 000a 9BBB      		out 0x1b,r25
  12:lcd.c         **** 
  13:lcd.c         **** LCD_PORT |= ((Dane ) & 0xf0);
  32               		.loc 1 13 0
  33 000c 9BB3      		in r25,0x1b
  34 000e 282F      		mov r18,r24
  35 0010 207F      		andi r18,lo8(-16)
  36 0012 922B      		or r25,r18
  37 0014 9BBB      		out 0x1b,r25
  14:lcd.c         **** LCD_PORT &=~RW;
  38               		.loc 1 14 0
  39 0016 D998      		cbi 0x1b,1
  15:lcd.c         **** LCD_PORT  |=EN;
  40               		.loc 1 15 0
  41 0018 DA9A      		sbi 0x1b,2
  42               	.LVL1:
  43               	.LBB28:
  44               	.LBB29:
  45               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  46               		.loc 2 163 0
  47 001a E3EF      		ldi r30,lo8(499)
  48 001c F1E0      		ldi r31,hi8(499)
  49 001e 3197      	1:	sbiw r30,1
  50 0020 01F4      		brne 1b
  51 0022 00C0      		rjmp .
  52 0024 0000      		nop
  53               	.LBE29:
  54               	.LBE28:
  16:lcd.c         **** _delay_ms(2);
  17:lcd.c         **** LCD_PORT  &=~EN;
  55               		.loc 1 17 0
  56 0026 DA98      		cbi 0x1b,2
  18:lcd.c         **** 
  19:lcd.c         **** LCD_PORT &= 0x0f;
  57               		.loc 1 19 0
  58 0028 9BB3      		in r25,0x1b
  59 002a 9F70      		andi r25,lo8(15)
  60 002c 9BBB      		out 0x1b,r25
  20:lcd.c         **** 
  21:lcd.c         **** LCD_PORT  |= ((Dane<<4) &  0xf0);
  61               		.loc 1 21 0
  62 002e 2BB3      		in r18,0x1b
  63 0030 F0E1      		ldi r31,lo8(16)
  64 0032 8F9F      		mul r24,r31
  65 0034 C001      		movw r24,r0
  66 0036 1124      		clr __zero_reg__
  67               	.LVL2:
  68 0038 822B      		or r24,r18
  69 003a 8BBB      		out 0x1b,r24
  22:lcd.c         **** LCD_PORT  |=EN;
  70               		.loc 1 22 0
  71 003c DA9A      		sbi 0x1b,2
  72               	.LVL3:
  73               	.LBB30:
  74               	.LBB31:
  75               		.loc 2 163 0
  76 003e 83EF      		ldi r24,lo8(499)
  77 0040 91E0      		ldi r25,hi8(499)
  78 0042 0197      	1:	sbiw r24,1
  79 0044 01F4      		brne 1b
  80 0046 00C0      		rjmp .
  81 0048 0000      		nop
  82               	.LBE31:
  83               	.LBE30:
  23:lcd.c         **** _delay_ms(2);
  24:lcd.c         **** LCD_PORT  &=~EN;
  84               		.loc 1 24 0
  85 004a DA98      		cbi 0x1b,2
  86 004c 0895      		ret
  87               		.cfi_endproc
  88               	.LFE6:
  90               	.global	lcdData
  92               	lcdData:
  93               	.LFB7:
  25:lcd.c         **** 
  26:lcd.c         **** 
  27:lcd.c         **** }
  28:lcd.c         **** void lcdData(unsigned char l)
  29:lcd.c         **** {
  94               		.loc 1 29 0
  95               		.cfi_startproc
  96               	.LVL4:
  97               	/* prologue: function */
  98               	/* frame size = 0 */
  99               	/* stack size = 0 */
 100               	.L__stack_usage = 0
  30:lcd.c         **** LCD_PORT |=RS;  //wysylanie danych
 101               		.loc 1 30 0
 102 004e D89A      		sbi 0x1b,0
  31:lcd.c         **** LCD_PORT &=~RW;
 103               		.loc 1 31 0
 104 0050 D998      		cbi 0x1b,1
  32:lcd.c         **** LCD_PORT  &=~EN;
 105               		.loc 1 32 0
 106 0052 DA98      		cbi 0x1b,2
  33:lcd.c         **** LCD_PORT &= 0x0f;
 107               		.loc 1 33 0
 108 0054 9BB3      		in r25,0x1b
 109 0056 9F70      		andi r25,lo8(15)
 110 0058 9BBB      		out 0x1b,r25
  34:lcd.c         **** LCD_PORT |=((l ) & 0xf0);
 111               		.loc 1 34 0
 112 005a 9BB3      		in r25,0x1b
 113 005c 282F      		mov r18,r24
 114 005e 207F      		andi r18,lo8(-16)
 115 0060 922B      		or r25,r18
 116 0062 9BBB      		out 0x1b,r25
  35:lcd.c         **** LCD_PORT &=~RW;
 117               		.loc 1 35 0
 118 0064 D998      		cbi 0x1b,1
  36:lcd.c         **** LCD_PORT  |=EN;
 119               		.loc 1 36 0
 120 0066 DA9A      		sbi 0x1b,2
 121               	.LVL5:
 122               	.LBB32:
 123               	.LBB33:
 124               		.loc 2 163 0
 125 0068 E3EF      		ldi r30,lo8(499)
 126 006a F1E0      		ldi r31,hi8(499)
 127 006c 3197      	1:	sbiw r30,1
 128 006e 01F4      		brne 1b
 129 0070 00C0      		rjmp .
 130 0072 0000      		nop
 131               	.LBE33:
 132               	.LBE32:
  37:lcd.c         **** _delay_ms(2);
  38:lcd.c         **** LCD_PORT  &=~EN;
 133               		.loc 1 38 0
 134 0074 DA98      		cbi 0x1b,2
  39:lcd.c         **** LCD_PORT &= 0x0f;
 135               		.loc 1 39 0
 136 0076 9BB3      		in r25,0x1b
 137 0078 9F70      		andi r25,lo8(15)
 138 007a 9BBB      		out 0x1b,r25
  40:lcd.c         **** LCD_PORT  |= ((l<<4) &  0xf0);
 139               		.loc 1 40 0
 140 007c 2BB3      		in r18,0x1b
 141 007e F0E1      		ldi r31,lo8(16)
 142 0080 8F9F      		mul r24,r31
 143 0082 C001      		movw r24,r0
 144 0084 1124      		clr __zero_reg__
 145               	.LVL6:
 146 0086 822B      		or r24,r18
 147 0088 8BBB      		out 0x1b,r24
  41:lcd.c         **** LCD_PORT  |=EN;
 148               		.loc 1 41 0
 149 008a DA9A      		sbi 0x1b,2
 150               	.LVL7:
 151               	.LBB34:
 152               	.LBB35:
 153               		.loc 2 163 0
 154 008c 83EF      		ldi r24,lo8(499)
 155 008e 91E0      		ldi r25,hi8(499)
 156 0090 0197      	1:	sbiw r24,1
 157 0092 01F4      		brne 1b
 158 0094 00C0      		rjmp .
 159 0096 0000      		nop
 160               	.LBE35:
 161               	.LBE34:
  42:lcd.c         **** _delay_ms(2);
  43:lcd.c         **** LCD_PORT  &=~EN;
 162               		.loc 1 43 0
 163 0098 DA98      		cbi 0x1b,2
 164 009a 0895      		ret
 165               		.cfi_endproc
 166               	.LFE7:
 168               	.global	lcdInit
 170               	lcdInit:
 171               	.LFB8:
  44:lcd.c         **** 
  45:lcd.c         **** }
  46:lcd.c         **** 
  47:lcd.c         **** void lcdInit(void)
  48:lcd.c         **** {
 172               		.loc 1 48 0
 173               		.cfi_startproc
 174               	/* prologue: function */
 175               	/* frame size = 0 */
 176               	/* stack size = 0 */
 177               	.L__stack_usage = 0
  49:lcd.c         **** LCD_PORT &=~RS;
 178               		.loc 1 49 0
 179 009c D898      		cbi 0x1b,0
  50:lcd.c         **** LCD_PORT  &=~EN;
 180               		.loc 1 50 0
 181 009e DA98      		cbi 0x1b,2
  51:lcd.c         **** LCD_PORT &=~RW;
 182               		.loc 1 51 0
 183 00a0 D998      		cbi 0x1b,1
  52:lcd.c         **** LCD_PORT |= 0x30;
 184               		.loc 1 52 0
 185 00a2 8BB3      		in r24,0x1b
 186 00a4 8063      		ori r24,lo8(48)
 187 00a6 8BBB      		out 0x1b,r24
 188               	.LVL8:
 189               	.LBB36:
 190               	.LBB37:
 191               		.loc 2 163 0
 192 00a8 8FE0      		ldi r24,lo8(9999)
 193 00aa 97E2      		ldi r25,hi8(9999)
 194 00ac 0197      	1:	sbiw r24,1
 195 00ae 01F4      		brne 1b
 196 00b0 00C0      		rjmp .
 197 00b2 0000      		nop
 198               	.LBE37:
 199               	.LBE36:
  53:lcd.c         **** _delay_ms(40);
  54:lcd.c         **** LCD_PORT  |=EN;
 200               		.loc 1 54 0
 201 00b4 DA9A      		sbi 0x1b,2
  55:lcd.c         **** LCD_PORT  &=~EN;
 202               		.loc 1 55 0
 203 00b6 DA98      		cbi 0x1b,2
 204               	.LVL9:
 205               	.LBB38:
 206               	.LBB39:
 207               		.loc 2 163 0
 208 00b8 81EE      		ldi r24,lo8(1249)
 209 00ba 94E0      		ldi r25,hi8(1249)
 210 00bc 0197      	1:	sbiw r24,1
 211 00be 01F4      		brne 1b
 212 00c0 00C0      		rjmp .
 213 00c2 0000      		nop
 214               	.LBE39:
 215               	.LBE38:
  56:lcd.c         **** _delay_ms(5);
  57:lcd.c         **** LCD_PORT  |=EN;
 216               		.loc 1 57 0
 217 00c4 DA9A      		sbi 0x1b,2
  58:lcd.c         **** LCD_PORT  &=~EN;
 218               		.loc 1 58 0
 219 00c6 DA98      		cbi 0x1b,2
 220               	.LVL10:
 221               	.LBB40:
 222               	.LBB41:
 223               		.loc 2 163 0
 224 00c8 81EE      		ldi r24,lo8(1249)
 225 00ca 94E0      		ldi r25,hi8(1249)
 226 00cc 0197      	1:	sbiw r24,1
 227 00ce 01F4      		brne 1b
 228 00d0 00C0      		rjmp .
 229 00d2 0000      		nop
 230               	.LBE41:
 231               	.LBE40:
  59:lcd.c         **** _delay_ms(5);
  60:lcd.c         **** LCD_PORT  |=EN;
 232               		.loc 1 60 0
 233 00d4 DA9A      		sbi 0x1b,2
  61:lcd.c         **** LCD_PORT  &=~EN;
 234               		.loc 1 61 0
 235 00d6 DA98      		cbi 0x1b,2
 236               	.LVL11:
 237               	.LBB42:
 238               	.LBB43:
 239               		.loc 2 163 0
 240 00d8 83EF      		ldi r24,lo8(499)
 241 00da 91E0      		ldi r25,hi8(499)
 242 00dc 0197      	1:	sbiw r24,1
 243 00de 01F4      		brne 1b
 244 00e0 00C0      		rjmp .
 245 00e2 0000      		nop
 246               	.LBE43:
 247               	.LBE42:
  62:lcd.c         **** _delay_ms(2);
  63:lcd.c         **** 
  64:lcd.c         **** LCD_PORT &= 0x20;
 248               		.loc 1 64 0
 249 00e4 8BB3      		in r24,0x1b
 250 00e6 8072      		andi r24,lo8(32)
 251 00e8 8BBB      		out 0x1b,r24
  65:lcd.c         **** LCD_PORT  |=EN;
 252               		.loc 1 65 0
 253 00ea DA9A      		sbi 0x1b,2
  66:lcd.c         **** LCD_PORT  &=~EN;
 254               		.loc 1 66 0
 255 00ec DA98      		cbi 0x1b,2
  67:lcd.c         **** lcdcmd(0x28);   //set data length 4 bit 2 line
 256               		.loc 1 67 0
 257 00ee 88E2      		ldi r24,lo8(40)
 258 00f0 0E94 0000 		call lcdcmd
 259               	.LVL12:
 260               	.LBB44:
 261               	.LBB45:
 262               		.loc 2 163 0
 263 00f4 83ED      		ldi r24,lo8(12499)
 264 00f6 90E3      		ldi r25,hi8(12499)
 265 00f8 0197      	1:	sbiw r24,1
 266 00fa 01F4      		brne 1b
 267 00fc 00C0      		rjmp .
 268 00fe 0000      		nop
 269               	.LBE45:
 270               	.LBE44:
  68:lcd.c         **** _delay_ms(50);
  69:lcd.c         **** lcdcmd(0x0E);   // set display on cursor on blink on
 271               		.loc 1 69 0
 272 0100 8EE0      		ldi r24,lo8(14)
 273 0102 0E94 0000 		call lcdcmd
 274               	.LVL13:
 275               	.LBB46:
 276               	.LBB47:
 277               		.loc 2 163 0
 278 0106 83ED      		ldi r24,lo8(12499)
 279 0108 90E3      		ldi r25,hi8(12499)
 280 010a 0197      	1:	sbiw r24,1
 281 010c 01F4      		brne 1b
 282 010e 00C0      		rjmp .
 283 0110 0000      		nop
 284               	.LBE47:
 285               	.LBE46:
  70:lcd.c         **** _delay_ms(50);
  71:lcd.c         **** lcdcmd(0x01); // clear lcd
 286               		.loc 1 71 0
 287 0112 81E0      		ldi r24,lo8(1)
 288 0114 0E94 0000 		call lcdcmd
 289               	.LVL14:
 290               	.LBB48:
 291               	.LBB49:
 292               		.loc 2 163 0
 293 0118 83ED      		ldi r24,lo8(12499)
 294 011a 90E3      		ldi r25,hi8(12499)
 295 011c 0197      	1:	sbiw r24,1
 296 011e 01F4      		brne 1b
 297 0120 00C0      		rjmp .
 298 0122 0000      		nop
 299               	.LBE49:
 300               	.LBE48:
  72:lcd.c         **** _delay_ms(50);
  73:lcd.c         **** lcdcmd(0x06);  // cursor shift direction
 301               		.loc 1 73 0
 302 0124 86E0      		ldi r24,lo8(6)
 303 0126 0E94 0000 		call lcdcmd
 304               	.LVL15:
 305               	.LBB50:
 306               	.LBB51:
 307               		.loc 2 163 0
 308 012a 83ED      		ldi r24,lo8(12499)
 309 012c 90E3      		ldi r25,hi8(12499)
 310 012e 0197      	1:	sbiw r24,1
 311 0130 01F4      		brne 1b
 312 0132 00C0      		rjmp .
 313 0134 0000      		nop
 314               	.LBE51:
 315               	.LBE50:
  74:lcd.c         **** _delay_ms(50);
  75:lcd.c         **** lcdcmd(0x80);  //set ram address
 316               		.loc 1 75 0
 317 0136 80E8      		ldi r24,lo8(-128)
 318 0138 0E94 0000 		call lcdcmd
 319               	.LVL16:
 320               	.LBB52:
 321               	.LBB53:
 322               		.loc 2 163 0
 323 013c 83ED      		ldi r24,lo8(12499)
 324 013e 90E3      		ldi r25,hi8(12499)
 325 0140 0197      	1:	sbiw r24,1
 326 0142 01F4      		brne 1b
 327 0144 00C0      		rjmp .
 328 0146 0000      		nop
 329 0148 0895      		ret
 330               	.LBE53:
 331               	.LBE52:
 332               		.cfi_endproc
 333               	.LFE8:
 335               	.global	prints
 337               	prints:
 338               	.LFB9:
  76:lcd.c         **** _delay_ms(50);
  77:lcd.c         **** }
  78:lcd.c         **** 
  79:lcd.c         **** 
  80:lcd.c         **** 
  81:lcd.c         **** void prints(const char *s)
  82:lcd.c         ****   {
 339               		.loc 1 82 0
 340               		.cfi_startproc
 341               	.LVL17:
 342 014a CF93      		push r28
 343               	.LCFI0:
 344               		.cfi_def_cfa_offset 3
 345               		.cfi_offset 28, -2
 346 014c DF93      		push r29
 347               	.LCFI1:
 348               		.cfi_def_cfa_offset 4
 349               		.cfi_offset 29, -3
 350               	/* prologue: function */
 351               	/* frame size = 0 */
 352               	/* stack size = 2 */
 353               	.L__stack_usage = 2
 354 014e EC01      		movw r28,r24
 355               	.LVL18:
 356               	.L5:
  83:lcd.c         **** 
  84:lcd.c         ****     while (*s)
 357               		.loc 1 84 0
 358 0150 8991      		ld r24,Y+
 359               	.LVL19:
 360 0152 8823      		tst r24
 361 0154 01F0      		breq .L8
  85:lcd.c         ****       {
  86:lcd.c         **** 	 lcdData(*s);
 362               		.loc 1 86 0
 363 0156 0E94 0000 		call lcdData
 364               	.LVL20:
 365 015a 00C0      		rjmp .L5
 366               	.LVL21:
 367               	.L8:
 368               	/* epilogue start */
  87:lcd.c         **** 	 s++;
  88:lcd.c         ****       }
  89:lcd.c         ****   }
 369               		.loc 1 89 0
 370 015c DF91      		pop r29
 371 015e CF91      		pop r28
 372               	.LVL22:
 373 0160 0895      		ret
 374               		.cfi_endproc
 375               	.LFE9:
 377               	.global	gotoXy
 379               	gotoXy:
 380               	.LFB10:
  90:lcd.c         **** 
  91:lcd.c         **** void gotoXy(unsigned char  x,unsigned char y)
  92:lcd.c         **** {
 381               		.loc 1 92 0
 382               		.cfi_startproc
 383               	.LVL23:
 384               	/* prologue: function */
 385               	/* frame size = 0 */
 386               	/* stack size = 0 */
 387               	.L__stack_usage = 0
  93:lcd.c         ****  if(x<40)
 388               		.loc 1 93 0
 389 0162 8832      		cpi r24,lo8(40)
 390 0164 00F4      		brsh .L9
  94:lcd.c         ****  {
  95:lcd.c         ****   if(y) x |= 0x40;
 391               		.loc 1 95 0
 392 0166 6111      		cpse r22,__zero_reg__
 393               		.loc 1 95 0 is_stmt 0 discriminator 1
 394 0168 8064      		ori r24,lo8(64)
 395               	.LVL24:
 396               	.L11:
  96:lcd.c         ****   x |=0x80;
  97:lcd.c         ****   lcdcmd(x);
 397               		.loc 1 97 0 is_stmt 1
 398 016a 8068      		ori r24,lo8(-128)
 399               	.LVL25:
 400 016c 0C94 0000 		jmp lcdcmd
 401               	.LVL26:
 402               	.L9:
 403 0170 0895      		ret
 404               		.cfi_endproc
 405               	.LFE10:
 407               	.global	integerToLcd
 409               	integerToLcd:
 410               	.LFB11:
  98:lcd.c         ****   }
  99:lcd.c         **** 
 100:lcd.c         **** }
 101:lcd.c         **** void integerToLcd(int integer )
 102:lcd.c         **** {
 411               		.loc 1 102 0
 412               		.cfi_startproc
 413               	.LVL27:
 414 0172 EF92      		push r14
 415               	.LCFI2:
 416               		.cfi_def_cfa_offset 3
 417               		.cfi_offset 14, -2
 418 0174 FF92      		push r15
 419               	.LCFI3:
 420               		.cfi_def_cfa_offset 4
 421               		.cfi_offset 15, -3
 422 0176 0F93      		push r16
 423               	.LCFI4:
 424               		.cfi_def_cfa_offset 5
 425               		.cfi_offset 16, -4
 426 0178 1F93      		push r17
 427               	.LCFI5:
 428               		.cfi_def_cfa_offset 6
 429               		.cfi_offset 17, -5
 430 017a CF93      		push r28
 431               	.LCFI6:
 432               		.cfi_def_cfa_offset 7
 433               		.cfi_offset 28, -6
 434 017c DF93      		push r29
 435               	.LCFI7:
 436               		.cfi_def_cfa_offset 8
 437               		.cfi_offset 29, -7
 438 017e 1F92      		push __zero_reg__
 439               	.LCFI8:
 440               		.cfi_def_cfa_offset 9
 441 0180 CDB7      		in r28,__SP_L__
 442 0182 DEB7      		in r29,__SP_H__
 443               	.LCFI9:
 444               		.cfi_def_cfa_register 28
 445               	/* prologue: function */
 446               	/* frame size = 1 */
 447               	/* stack size = 7 */
 448               	.L__stack_usage = 7
 449 0184 7C01      		movw r14,r24
 103:lcd.c         **** 
 104:lcd.c         **** unsigned char thousands,hundreds,tens,ones;
 105:lcd.c         **** if(integer >=0) //wyswietlanie dodatnich liczb 
 450               		.loc 1 105 0
 451 0186 97FD      		sbrc r25,7
 452 0188 00C0      		rjmp .L16
 106:lcd.c         **** {
 107:lcd.c         ****   //wyswietlenie znaku
 108:lcd.c         ****   lcdData(0x2B); //+
 453               		.loc 1 108 0
 454 018a 8BE2      		ldi r24,lo8(43)
 455               	.LVL28:
 456 018c 0E94 0000 		call lcdData
 457               	.LVL29:
 109:lcd.c         ****   //wyswietlenie liczby
 110:lcd.c         ****   thousands = integer / 1000;
 458               		.loc 1 110 0
 459 0190 C701      		movw r24,r14
 460 0192 68EE      		ldi r22,lo8(-24)
 461 0194 73E0      		ldi r23,lo8(3)
 462 0196 0E94 0000 		call __divmodhi4
 463 019a 8B01      		movw r16,r22
 464               	.LVL30:
 111:lcd.c         **** 
 112:lcd.c         ****     lcdData(thousands + 0x30);
 465               		.loc 1 112 0
 466 019c 80E3      		ldi r24,lo8(48)
 467 019e 860F      		add r24,r22
 468 01a0 0E94 0000 		call lcdData
 469               	.LVL31:
 113:lcd.c         **** 
 114:lcd.c         ****    hundreds = ((integer - thousands*1000)-1) / 100;
 470               		.loc 1 114 0
 471 01a4 28E1      		ldi r18,lo8(24)
 472 01a6 3CEF      		ldi r19,lo8(-4)
 473 01a8 029F      		mul r16,r18
 474 01aa C001      		movw r24,r0
 475 01ac 039F      		mul r16,r19
 476 01ae 900D      		add r25,r0
 477 01b0 129F      		mul r17,r18
 478 01b2 900D      		add r25,r0
 479 01b4 1124      		clr r1
 480               	.LVL32:
 481 01b6 8E0D      		add r24,r14
 482 01b8 9F1D      		adc r25,r15
 483               	.LVL33:
 484 01ba 0197      		sbiw r24,1
 485 01bc 04E6      		ldi r16,lo8(100)
 486 01be 10E0      		ldi r17,0
 487               	.LVL34:
 488 01c0 B801      		movw r22,r16
 489 01c2 0E94 0000 		call __divmodhi4
 115:lcd.c         **** 
 116:lcd.c         ****   lcdData( hundreds + 0x30);
 490               		.loc 1 116 0
 491 01c6 80E3      		ldi r24,lo8(48)
 492 01c8 860F      		add r24,r22
 493 01ca 0E94 0000 		call lcdData
 494               	.LVL35:
 117:lcd.c         **** tens=(integer%100)/10;
 495               		.loc 1 117 0
 496 01ce C701      		movw r24,r14
 497 01d0 B801      		movw r22,r16
 498 01d2 0E94 0000 		call __divmodhi4
 499 01d6 0AE0      		ldi r16,lo8(10)
 500 01d8 10E0      		ldi r17,0
 501 01da B801      		movw r22,r16
 502 01dc 0E94 0000 		call __divmodhi4
 118:lcd.c         **** 
 119:lcd.c         ****   lcdData( tens + 0x30);
 503               		.loc 1 119 0
 504 01e0 80E3      		ldi r24,lo8(48)
 505 01e2 860F      		add r24,r22
 506 01e4 0E94 0000 		call lcdData
 507               	.LVL36:
 120:lcd.c         ****   ones=integer%10;
 508               		.loc 1 120 0
 509 01e8 C701      		movw r24,r14
 510 01ea B801      		movw r22,r16
 511 01ec 00C0      		rjmp .L17
 512               	.LVL37:
 513               	.L16:
 121:lcd.c         **** 
 122:lcd.c         ****   lcdData( ones + 0x30);
 123:lcd.c         **** }
 124:lcd.c         **** 
 125:lcd.c         **** else //wyswietlanie ujemnych liczb
 126:lcd.c         **** {
 127:lcd.c         ****   //wyswietlenie znaku
 128:lcd.c         ****   lcdData(0x2D); //-
 514               		.loc 1 128 0
 515 01ee 8DE2      		ldi r24,lo8(45)
 516 01f0 0E94 0000 		call lcdData
 517               	.LVL38:
 129:lcd.c         ****   //wyswietlenie liczby
 130:lcd.c         ****   integer = integer*(-1);
 518               		.loc 1 130 0
 519 01f4 0027      		clr r16
 520 01f6 1127      		clr r17
 521 01f8 0E19      		sub r16,r14
 522 01fa 1F09      		sbc r17,r15
 523               	.LVL39:
 131:lcd.c         ****   thousands = integer / 1000;
 524               		.loc 1 131 0
 525 01fc C801      		movw r24,r16
 526 01fe 68EE      		ldi r22,lo8(-24)
 527 0200 73E0      		ldi r23,lo8(3)
 528 0202 0E94 0000 		call __divmodhi4
 529               	.LVL40:
 132:lcd.c         **** 
 133:lcd.c         ****       lcdData(thousands + 0x30);
 530               		.loc 1 133 0
 531 0206 80E3      		ldi r24,lo8(48)
 532 0208 860F      		add r24,r22
 533 020a 6983      		std Y+1,r22
 534 020c 0E94 0000 		call lcdData
 535               	.LVL41:
 134:lcd.c         **** 
 135:lcd.c         ****      hundreds = ((integer - thousands*1000)-1) / 100;
 536               		.loc 1 135 0
 537 0210 88E1      		ldi r24,lo8(24)
 538 0212 9CEF      		ldi r25,lo8(-4)
 539 0214 6981      		ldd r22,Y+1
 540 0216 689F      		mul r22,r24
 541 0218 9001      		movw r18,r0
 542 021a 699F      		mul r22,r25
 543 021c 300D      		add r19,r0
 544 021e 1124      		clr __zero_reg__
 545 0220 2E19      		sub r18,r14
 546 0222 3F09      		sbc r19,r15
 547 0224 C901      		movw r24,r18
 548 0226 0197      		sbiw r24,1
 549 0228 24E6      		ldi r18,lo8(100)
 550 022a E22E      		mov r14,r18
 551 022c F12C      		mov r15,__zero_reg__
 552 022e B701      		movw r22,r14
 553 0230 0E94 0000 		call __divmodhi4
 136:lcd.c         **** 
 137:lcd.c         ****     lcdData( hundreds + 0x30);
 554               		.loc 1 137 0
 555 0234 80E3      		ldi r24,lo8(48)
 556 0236 860F      		add r24,r22
 557 0238 0E94 0000 		call lcdData
 558               	.LVL42:
 138:lcd.c         ****   tens=(integer%100)/10;
 559               		.loc 1 138 0
 560 023c C801      		movw r24,r16
 561 023e B701      		movw r22,r14
 562 0240 0E94 0000 		call __divmodhi4
 563 0244 3AE0      		ldi r19,lo8(10)
 564 0246 E32E      		mov r14,r19
 565 0248 F12C      		mov r15,__zero_reg__
 566 024a B701      		movw r22,r14
 567 024c 0E94 0000 		call __divmodhi4
 139:lcd.c         **** 
 140:lcd.c         ****     lcdData( tens + 0x30);
 568               		.loc 1 140 0
 569 0250 80E3      		ldi r24,lo8(48)
 570 0252 860F      		add r24,r22
 571 0254 0E94 0000 		call lcdData
 572               	.LVL43:
 141:lcd.c         ****     ones=integer%10;
 573               		.loc 1 141 0
 574 0258 C801      		movw r24,r16
 575 025a B701      		movw r22,r14
 576               	.LVL44:
 577               	.L17:
 578 025c 0E94 0000 		call __divmodhi4
 579               	.LVL45:
 142:lcd.c         **** 
 143:lcd.c         ****     lcdData( ones + 0x30);
 580               		.loc 1 143 0
 581 0260 805D      		subi r24,lo8(-(48))
 582               	/* epilogue start */
 144:lcd.c         **** }
 145:lcd.c         **** 
 146:lcd.c         **** }
 583               		.loc 1 146 0
 584 0262 0F90      		pop __tmp_reg__
 585 0264 DF91      		pop r29
 586 0266 CF91      		pop r28
 587 0268 1F91      		pop r17
 588 026a 0F91      		pop r16
 589 026c FF90      		pop r15
 590 026e EF90      		pop r14
 143:lcd.c         **** }
 591               		.loc 1 143 0
 592 0270 0C94 0000 		jmp lcdData
 593               	.LVL46:
 594               		.cfi_endproc
 595               	.LFE11:
 597               	.global	lcd_clr
 599               	lcd_clr:
 600               	.LFB12:
 147:lcd.c         **** 
 148:lcd.c         **** void lcd_clr(void)
 149:lcd.c         **** {
 601               		.loc 1 149 0
 602               		.cfi_startproc
 603               	/* prologue: function */
 604               	/* frame size = 0 */
 605               	/* stack size = 0 */
 606               	.L__stack_usage = 0
 150:lcd.c         ****   lcdcmd(0x01); //czyszczenie wyswietlacza
 607               		.loc 1 150 0
 608 0274 81E0      		ldi r24,lo8(1)
 609 0276 0C94 0000 		jmp lcdcmd
 610               	.LVL47:
 611               		.cfi_endproc
 612               	.LFE12:
 614               	.Letext0:
 615               		.file 3 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 lcd.c
     /tmp/cc7EjjNp.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc7EjjNp.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc7EjjNp.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc7EjjNp.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc7EjjNp.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc7EjjNp.s:12     .text:0000000000000000 lcdcmd
     /tmp/cc7EjjNp.s:92     .text:000000000000004e lcdData
     /tmp/cc7EjjNp.s:170    .text:000000000000009c lcdInit
     /tmp/cc7EjjNp.s:337    .text:000000000000014a prints
     /tmp/cc7EjjNp.s:379    .text:0000000000000162 gotoXy
     /tmp/cc7EjjNp.s:409    .text:0000000000000172 integerToLcd
     /tmp/cc7EjjNp.s:599    .text:0000000000000274 lcd_clr

UNDEFINED SYMBOLS
__divmodhi4
