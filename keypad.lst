   1               		.file	"keypad.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	keypad
  12               	keypad:
  13               	.LFB6:
  14               		.file 1 "keypad.c"
   1:keypad.c      **** #include "keypad.h"
   2:keypad.c      **** 
   3:keypad.c      **** char keypad(struct Key *klaw) 
   4:keypad.c      ****  {
  15               		.loc 1 4 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 FC01      		movw r30,r24
   5:keypad.c      **** 	klaw->result=0;
  23               		.loc 1 5 0
  24 0002 1082      		st Z,__zero_reg__
   6:keypad.c      **** 	KB_DIR =0b11110000; //wymuszenie zer dla wszystkich kolumn
  25               		.loc 1 6 0
  26 0004 80EF      		ldi r24,lo8(-16)
  27               	.LVL1:
  28 0006 87BB      		out 0x17,r24
   7:keypad.c      **** 	KB_PORT=0b00001111;
  29               		.loc 1 7 0
  30 0008 9FE0      		ldi r25,lo8(15)
  31 000a 98BB      		out 0x18,r25
  32               	.LVL2:
  33               	.LBB6:
  34               	.LBB7:
  35               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  36               		.loc 2 163 0
  37 000c A7EA      		ldi r26,lo8(24999)
  38 000e B1E6      		ldi r27,hi8(24999)
  39 0010 1197      	1:	sbiw r26,1
  40 0012 01F4      		brne 1b
  41 0014 00C0      		rjmp .
  42 0016 0000      		nop
  43               	.LBE7:
  44               	.LBE6:
   8:keypad.c      **** 	_delay_ms(100);
   9:keypad.c      **** 	klaw->result = KB_PIN;
  45               		.loc 1 9 0
  46 0018 26B3      		in r18,0x16
  47 001a 2083      		st Z,r18
  10:keypad.c      **** 
  11:keypad.c      **** 	//odczyt wierszy
  12:keypad.c      **** 	KB_DIR =0b00001111; //wymuszenie zer dla wszystkich wierszy
  48               		.loc 1 12 0
  49 001c 97BB      		out 0x17,r25
  13:keypad.c      **** 	KB_PORT=0b11110000;
  50               		.loc 1 13 0
  51 001e 88BB      		out 0x18,r24
  52               	.LVL3:
  53               	.LBB8:
  54               	.LBB9:
  55               		.loc 2 163 0
  56 0020 87EA      		ldi r24,lo8(24999)
  57 0022 91E6      		ldi r25,hi8(24999)
  58 0024 0197      	1:	sbiw r24,1
  59 0026 01F4      		brne 1b
  60 0028 00C0      		rjmp .
  61 002a 0000      		nop
  62               	.LBE9:
  63               	.LBE8:
  14:keypad.c      **** 	_delay_ms(100);
  15:keypad.c      **** 	klaw->result |= KB_PIN; 
  64               		.loc 1 15 0
  65 002c 86B3      		in r24,0x16
  66 002e 9081      		ld r25,Z
  67 0030 892B      		or r24,r25
  68 0032 8083      		st Z,r24
  16:keypad.c      **** 
  17:keypad.c      **** 	return klaw->result; //ostatnio wcisniety
  18:keypad.c      **** }
  69               		.loc 1 18 0
  70 0034 0895      		ret
  71               		.cfi_endproc
  72               	.LFE6:
  74               	.global	keypad_proc
  76               	keypad_proc:
  77               	.LFB7:
  19:keypad.c      **** 
  20:keypad.c      **** void keypad_proc(struct Key *klaw)
  21:keypad.c      **** {
  78               		.loc 1 21 0
  79               		.cfi_startproc
  80               	.LVL4:
  81               	/* prologue: function */
  82               	/* frame size = 0 */
  83               	/* stack size = 0 */
  84               	.L__stack_usage = 0
  85 0036 FC01      		movw r30,r24
  22:keypad.c      **** 
  23:keypad.c      **** 	switch (klaw->result) // akcja dla ostanio wcisnietego klawisza
  86               		.loc 1 23 0
  87 0038 8081      		ld r24,Z
  88               	.LVL5:
  89 003a 873D      		cpi r24,lo8(-41)
  90 003c 01F4      		brne .+2
  91 003e 00C0      		rjmp .L4
  92 0040 00F4      		brsh .L5
  93 0042 873B      		cpi r24,lo8(-73)
  94 0044 01F4      		brne .+2
  95 0046 00C0      		rjmp .L6
  96 0048 00F4      		brsh .L7
  97 004a 8B37      		cpi r24,lo8(123)
  98 004c 01F0      		breq .L8
  99 004e 8D37      		cpi r24,lo8(125)
 100 0050 01F0      		breq .L9
 101 0052 8737      		cpi r24,lo8(119)
 102 0054 01F0      		breq .+2
 103 0056 00C0      		rjmp .L3
 104 0058 DF01      		movw r26,r30
 105 005a 1196      		adiw r26,1
 106 005c CF01      		movw r24,r30
 107 005e 4196      		adiw r24,17
 108 0060 00C0      		rjmp .L24
 109               	.L7:
 110 0062 8D3B      		cpi r24,lo8(-67)
 111 0064 01F4      		brne .+2
 112 0066 00C0      		rjmp .L11
 113 0068 8E3B      		cpi r24,lo8(-66)
 114 006a 01F4      		brne .+2
 115 006c 00C0      		rjmp .L12
 116 006e 8B3B      		cpi r24,lo8(-69)
 117 0070 01F0      		breq .+2
 118 0072 00C0      		rjmp .L3
  24:keypad.c      **** 	{
  25:keypad.c      **** 		//klawisze funkcyjne
  26:keypad.c      **** 		
  27:keypad.c      **** 		//case 0b01111110     : ; break; //A - potwierdzenie (accept)
  28:keypad.c      **** 		case 0b01111101     : klaw->flags |= KB_NEW; break; //B - wprowadzanie nowego obiektu
  29:keypad.c      **** 		case 0b01111011     : klaw->flags |= KB_CAL ; break; //C - kalibracja (calibration)
  30:keypad.c      **** 
  31:keypad.c      **** 		case 0b11100111     : { //* H
  32:keypad.c      **** 			if(!(klaw->flags & KB_H))
  33:keypad.c      **** 				klaw->buf[klaw->i]='H';
  34:keypad.c      **** 			klaw->flags |= KB_H;
  35:keypad.c      **** 
  36:keypad.c      **** 		} break; 
  37:keypad.c      **** 		case 0b10110111     :{ //# M
  38:keypad.c      **** 			if(!(klaw->flags & KB_M))
  39:keypad.c      **** 				klaw->buf[klaw->i]='M';
  40:keypad.c      **** 			klaw->flags |= KB_M;
  41:keypad.c      **** 	
  42:keypad.c      **** 		}break; 
  43:keypad.c      **** 
  44:keypad.c      **** 		case 0b01110111     : { //D - czyszczenie
  45:keypad.c      **** 			for(int i=0;i<16;i++) //czyszczenie bufora
  46:keypad.c      **** 				klaw->buf[i]='\0'; 
  47:keypad.c      **** 			//czyszczenie flag
  48:keypad.c      **** 			klaw->flags &= ~KB_H;
  49:keypad.c      **** 			klaw->flags &= ~KB_M;
  50:keypad.c      **** 			//czyszczenie wskaznika buforu
  51:keypad.c      **** 			klaw->i = 0;
  52:keypad.c      **** 		}; break; 
  53:keypad.c      **** 		
  54:keypad.c      **** 		
  55:keypad.c      **** 		//klawisz numeryczny     
  56:keypad.c      **** 		case 0b11101110     : klaw->buf[klaw->i]='1'; break; //1
  57:keypad.c      **** 		case 0b11011110     : klaw->buf[klaw->i]='2'; break; //2
  58:keypad.c      **** 		case 0b10111110     : klaw->buf[klaw->i]='3'; break; //3
  59:keypad.c      **** 		case 0b11101101     : klaw->buf[klaw->i]='4'; break; //4
  60:keypad.c      **** 		case 0b11011101     : klaw->buf[klaw->i]='5'; break; //5
  61:keypad.c      **** 		case 0b10111101     : klaw->buf[klaw->i]='6'; break; //6
  62:keypad.c      **** 		case 0b11101011     : klaw->buf[klaw->i]='7'; break; //7
  63:keypad.c      **** 		case 0b11011011     : klaw->buf[klaw->i]='8'; break; //8
  64:keypad.c      **** 		case 0b10111011     : klaw->buf[klaw->i]='9'; break; //9
 119               		.loc 1 64 0
 120 0074 A189      		ldd r26,Z+17
 121 0076 B289      		ldd r27,Z+18
 122 0078 AE0F      		add r26,r30
 123 007a BF1F      		adc r27,r31
 124 007c 89E3      		ldi r24,lo8(57)
 125 007e 00C0      		rjmp .L27
 126               	.L5:
  23:keypad.c      **** 	{
 127               		.loc 1 23 0
 128 0080 873E      		cpi r24,lo8(-25)
 129 0082 01F0      		breq .L14
 130 0084 00F4      		brsh .L15
 131 0086 8D3D      		cpi r24,lo8(-35)
 132 0088 01F4      		brne .+2
 133 008a 00C0      		rjmp .L16
 134 008c 8E3D      		cpi r24,lo8(-34)
 135 008e 01F4      		brne .+2
 136 0090 00C0      		rjmp .L17
 137 0092 8B3D      		cpi r24,lo8(-37)
 138 0094 01F0      		breq .+2
 139 0096 00C0      		rjmp .L3
  63:keypad.c      **** 		case 0b10111011     : klaw->buf[klaw->i]='9'; break; //9
 140               		.loc 1 63 0
 141 0098 A189      		ldd r26,Z+17
 142 009a B289      		ldd r27,Z+18
 143 009c AE0F      		add r26,r30
 144 009e BF1F      		adc r27,r31
 145 00a0 88E3      		ldi r24,lo8(56)
 146 00a2 00C0      		rjmp .L27
 147               	.L15:
  23:keypad.c      **** 	{
 148               		.loc 1 23 0
 149 00a4 8D3E      		cpi r24,lo8(-19)
 150 00a6 01F4      		brne .+2
 151 00a8 00C0      		rjmp .L19
 152 00aa 8E3E      		cpi r24,lo8(-18)
 153 00ac 01F0      		breq .L20
 154 00ae 8B3E      		cpi r24,lo8(-21)
 155 00b0 01F0      		breq .+2
 156 00b2 00C0      		rjmp .L3
  62:keypad.c      **** 		case 0b11011011     : klaw->buf[klaw->i]='8'; break; //8
 157               		.loc 1 62 0
 158 00b4 A189      		ldd r26,Z+17
 159 00b6 B289      		ldd r27,Z+18
 160 00b8 AE0F      		add r26,r30
 161 00ba BF1F      		adc r27,r31
 162 00bc 87E3      		ldi r24,lo8(55)
 163 00be 00C0      		rjmp .L27
 164               	.L9:
  28:keypad.c      **** 		case 0b01111011     : klaw->flags |= KB_CAL ; break; //C - kalibracja (calibration)
 165               		.loc 1 28 0
 166 00c0 8389      		ldd r24,Z+19
 167 00c2 8064      		ori r24,lo8(64)
 168 00c4 00C0      		rjmp .L26
 169               	.L8:
  29:keypad.c      **** 
 170               		.loc 1 29 0
 171 00c6 8389      		ldd r24,Z+19
 172 00c8 8062      		ori r24,lo8(32)
 173               	.L26:
 174 00ca 838B      		std Z+19,r24
 175 00cc 00C0      		rjmp .L3
 176               	.L14:
  32:keypad.c      **** 				klaw->buf[klaw->i]='H';
 177               		.loc 1 32 0
 178 00ce 8389      		ldd r24,Z+19
 179 00d0 83FD      		sbrc r24,3
 180 00d2 00C0      		rjmp .L22
  33:keypad.c      **** 			klaw->flags |= KB_H;
 181               		.loc 1 33 0
 182 00d4 A189      		ldd r26,Z+17
 183 00d6 B289      		ldd r27,Z+18
 184 00d8 AE0F      		add r26,r30
 185 00da BF1F      		adc r27,r31
 186 00dc 98E4      		ldi r25,lo8(72)
 187 00de 1196      		adiw r26,1
 188 00e0 9C93      		st X,r25
 189               	.L22:
  34:keypad.c      **** 
 190               		.loc 1 34 0
 191 00e2 8860      		ori r24,lo8(8)
 192 00e4 00C0      		rjmp .L26
 193               	.L6:
  38:keypad.c      **** 				klaw->buf[klaw->i]='M';
 194               		.loc 1 38 0
 195 00e6 8389      		ldd r24,Z+19
 196 00e8 82FD      		sbrc r24,2
 197 00ea 00C0      		rjmp .L23
  39:keypad.c      **** 			klaw->flags |= KB_M;
 198               		.loc 1 39 0
 199 00ec A189      		ldd r26,Z+17
 200 00ee B289      		ldd r27,Z+18
 201 00f0 AE0F      		add r26,r30
 202 00f2 BF1F      		adc r27,r31
 203 00f4 9DE4      		ldi r25,lo8(77)
 204 00f6 1196      		adiw r26,1
 205 00f8 9C93      		st X,r25
 206               	.L23:
  40:keypad.c      **** 	
 207               		.loc 1 40 0
 208 00fa 8460      		ori r24,lo8(4)
 209 00fc 00C0      		rjmp .L26
 210               	.L24:
 211               	.LVL6:
 212               	.LBB10:
  46:keypad.c      **** 			//czyszczenie flag
 213               		.loc 1 46 0 discriminator 3
 214 00fe 1D92      		st X+,__zero_reg__
 215               	.LVL7:
  45:keypad.c      **** 				klaw->buf[i]='\0'; 
 216               		.loc 1 45 0 discriminator 3
 217 0100 A817      		cp r26,r24
 218 0102 B907      		cpc r27,r25
 219 0104 01F4      		brne .L24
 220               	.LBE10:
  49:keypad.c      **** 			//czyszczenie wskaznika buforu
 221               		.loc 1 49 0
 222 0106 8389      		ldd r24,Z+19
 223 0108 837F      		andi r24,lo8(-13)
 224 010a 00C0      		rjmp .L26
 225               	.LVL8:
 226               	.L20:
  56:keypad.c      **** 		case 0b11011110     : klaw->buf[klaw->i]='2'; break; //2
 227               		.loc 1 56 0
 228 010c A189      		ldd r26,Z+17
 229 010e B289      		ldd r27,Z+18
 230 0110 AE0F      		add r26,r30
 231 0112 BF1F      		adc r27,r31
 232 0114 81E3      		ldi r24,lo8(49)
 233 0116 00C0      		rjmp .L27
 234               	.L17:
  57:keypad.c      **** 		case 0b10111110     : klaw->buf[klaw->i]='3'; break; //3
 235               		.loc 1 57 0
 236 0118 A189      		ldd r26,Z+17
 237 011a B289      		ldd r27,Z+18
 238 011c AE0F      		add r26,r30
 239 011e BF1F      		adc r27,r31
 240 0120 82E3      		ldi r24,lo8(50)
 241 0122 00C0      		rjmp .L27
 242               	.L12:
  58:keypad.c      **** 		case 0b11101101     : klaw->buf[klaw->i]='4'; break; //4
 243               		.loc 1 58 0
 244 0124 A189      		ldd r26,Z+17
 245 0126 B289      		ldd r27,Z+18
 246 0128 AE0F      		add r26,r30
 247 012a BF1F      		adc r27,r31
 248 012c 83E3      		ldi r24,lo8(51)
 249 012e 00C0      		rjmp .L27
 250               	.L19:
  59:keypad.c      **** 		case 0b11011101     : klaw->buf[klaw->i]='5'; break; //5
 251               		.loc 1 59 0
 252 0130 A189      		ldd r26,Z+17
 253 0132 B289      		ldd r27,Z+18
 254 0134 AE0F      		add r26,r30
 255 0136 BF1F      		adc r27,r31
 256 0138 84E3      		ldi r24,lo8(52)
 257 013a 00C0      		rjmp .L27
 258               	.L16:
  60:keypad.c      **** 		case 0b10111101     : klaw->buf[klaw->i]='6'; break; //6
 259               		.loc 1 60 0
 260 013c A189      		ldd r26,Z+17
 261 013e B289      		ldd r27,Z+18
 262 0140 AE0F      		add r26,r30
 263 0142 BF1F      		adc r27,r31
 264 0144 85E3      		ldi r24,lo8(53)
 265 0146 00C0      		rjmp .L27
 266               	.L11:
  61:keypad.c      **** 		case 0b11101011     : klaw->buf[klaw->i]='7'; break; //7
 267               		.loc 1 61 0
 268 0148 A189      		ldd r26,Z+17
 269 014a B289      		ldd r27,Z+18
 270 014c AE0F      		add r26,r30
 271 014e BF1F      		adc r27,r31
 272 0150 86E3      		ldi r24,lo8(54)
 273 0152 00C0      		rjmp .L27
 274               	.L4:
  65:keypad.c      **** 		case 0b11010111     : klaw->buf[klaw->i]='0'; break; //0
 275               		.loc 1 65 0
 276 0154 A189      		ldd r26,Z+17
 277 0156 B289      		ldd r27,Z+18
 278 0158 AE0F      		add r26,r30
 279 015a BF1F      		adc r27,r31
 280 015c 80E3      		ldi r24,lo8(48)
 281               	.L27:
 282 015e 1196      		adiw r26,1
 283 0160 8C93      		st X,r24
 284               	.L3:
  66:keypad.c      **** 		//default:
  67:keypad.c      **** 	}
  68:keypad.c      **** 	klaw->i=0;
 285               		.loc 1 68 0
 286 0162 128A      		std Z+18,__zero_reg__
 287 0164 118A      		std Z+17,__zero_reg__
  69:keypad.c      **** 	klaw->result=0xFF;
 288               		.loc 1 69 0
 289 0166 8FEF      		ldi r24,lo8(-1)
 290 0168 8083      		st Z,r24
 291 016a 0895      		ret
 292               		.cfi_endproc
 293               	.LFE7:
 295               		.comm	keypad_A,20,1
 296               	.Letext0:
 297               		.file 3 "/usr/lib/avr/include/stdint.h"
 298               		.file 4 "keypad.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 keypad.c
     /tmp/ccT3LY4M.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccT3LY4M.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccT3LY4M.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccT3LY4M.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccT3LY4M.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccT3LY4M.s:12     .text:0000000000000000 keypad
     /tmp/ccT3LY4M.s:76     .text:0000000000000036 keypad_proc
                            *COM*:0000000000000014 keypad_A

UNDEFINED SYMBOLS
__do_clear_bss
