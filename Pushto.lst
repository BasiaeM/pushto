   1               		.file	"Pushto.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	system_init
  12               	system_init:
  13               	.LFB7:
  14               		.file 1 "Pushto.c"
   1:Pushto.c      **** #include <avr/io.h>
   2:Pushto.c      **** #include <stdio.h>
   3:Pushto.c      **** 
   4:Pushto.c      **** #define F_CPU 2000000UL //kwarc 2MHz
   5:Pushto.c      **** #include <util/delay.h>
   6:Pushto.c      **** #include <avr/interrupt.h>
   7:Pushto.c      **** #include "lcd.h"
   8:Pushto.c      **** #include "encoder.h"
   9:Pushto.c      **** #include "keypad.h"
  10:Pushto.c      **** #include "pushto_lib.h"
  11:Pushto.c      ****     
  12:Pushto.c      **** 
  13:Pushto.c      **** 
  14:Pushto.c      **** void system_init (void)
  15:Pushto.c      **** {	
  15               		.loc 1 15 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  16:Pushto.c      **** 	/*Inicjalizacja przerwa≈Ñ zewnetrznych*/
  17:Pushto.c      **** 	MCUCR |=(1<<ISC00) | (1<<ISC10);	//ustawienie przerwan na zmiane na INT0 i INT1
  21               		.loc 1 17 0
  22 0000 85B7      		in r24,0x35
  23 0002 8560      		ori r24,lo8(5)
  24 0004 85BF      		out 0x35,r24
  18:Pushto.c      **** 	GICR |= (1<<INT0) | (1<<INT1); //wlaczenie zewnetrznych przerwan na INT0 i INT1
  25               		.loc 1 18 0
  26 0006 8BB7      		in r24,0x3b
  27 0008 806C      		ori r24,lo8(-64)
  28 000a 8BBF      		out 0x3b,r24
  19:Pushto.c      **** 	
  20:Pushto.c      **** 	/*inicjalizacja LCD*/
  21:Pushto.c      **** 	LCD_DIR = 0xFF;		//Ustawienie pinow dla wyswietlacza LCD
  29               		.loc 1 21 0
  30 000c 8FEF      		ldi r24,lo8(-1)
  31 000e 8ABB      		out 0x1a,r24
  22:Pushto.c      **** 
  23:Pushto.c      **** 	/*inicjalizacja encoderow*/
  24:Pushto.c      **** 	EN_DIR = 0b00000000; //Ustawienie pinow dla encoderow
  32               		.loc 1 24 0
  33 0010 11BA      		out 0x11,__zero_reg__
  25:Pushto.c      **** 	EN_PORT = 0b00001111; //pullupy dla encoderow
  34               		.loc 1 25 0
  35 0012 9FE0      		ldi r25,lo8(15)
  36 0014 92BB      		out 0x12,r25
  26:Pushto.c      **** 
  27:Pushto.c      **** 	encoder1.maskA=0b00000100;
  37               		.loc 1 27 0
  38 0016 E0E0      		ldi r30,lo8(encoder1)
  39 0018 F0E0      		ldi r31,hi8(encoder1)
  40 001a 94E0      		ldi r25,lo8(4)
  41 001c 9083      		st Z,r25
  28:Pushto.c      **** 	encoder1.maskB=0b00000001;
  42               		.loc 1 28 0
  43 001e 91E0      		ldi r25,lo8(1)
  44 0020 9183      		std Z+1,r25
  29:Pushto.c      **** 	encoder1.count=0; //----------------------------enkodery start 0 
  45               		.loc 1 29 0
  46 0022 1382      		std Z+3,__zero_reg__
  47 0024 1282      		std Z+2,__zero_reg__
  30:Pushto.c      **** 	encoder2.maskA=0b000001000;
  48               		.loc 1 30 0
  49 0026 E0E0      		ldi r30,lo8(encoder2)
  50 0028 F0E0      		ldi r31,hi8(encoder2)
  51 002a 98E0      		ldi r25,lo8(8)
  52 002c 9083      		st Z,r25
  31:Pushto.c      **** 	encoder2.maskB=0b000000010;
  53               		.loc 1 31 0
  54 002e 92E0      		ldi r25,lo8(2)
  55 0030 9183      		std Z+1,r25
  32:Pushto.c      **** 	encoder2.count=0;
  56               		.loc 1 32 0
  57 0032 1382      		std Z+3,__zero_reg__
  58 0034 1282      		std Z+2,__zero_reg__
  33:Pushto.c      **** 
  34:Pushto.c      **** 	//inicjalizacja klawiatury
  35:Pushto.c      **** 	keypad_A.i=0; //zerowanie wskaznika buforu
  59               		.loc 1 35 0
  60 0036 E0E0      		ldi r30,lo8(keypad_A)
  61 0038 F0E0      		ldi r31,hi8(keypad_A)
  62 003a 128A      		std Z+18,__zero_reg__
  63 003c 118A      		std Z+17,__zero_reg__
  36:Pushto.c      **** 	keypad_A.flags='\0';
  64               		.loc 1 36 0
  65 003e 138A      		std Z+19,__zero_reg__
  37:Pushto.c      **** 	
  38:Pushto.c      **** 	//############# Timer1 16bit config ####################
  39:Pushto.c      **** 	TCCR1A |= 0;   // not required since WGM11:0, both are zero (0)
  66               		.loc 1 39 0
  67 0040 9FB5      		in r25,0x2f
  68 0042 9FBD      		out 0x2f,r25
  40:Pushto.c      ****  	TCCR1B |= (1 << WGM12)|(1 << CS11)|(1 << CS10);   // Mode = CTC, Prescaler = 64
  69               		.loc 1 40 0
  70 0044 9EB5      		in r25,0x2e
  71 0046 9B60      		ori r25,lo8(11)
  72 0048 9EBD      		out 0x2e,r25
  41:Pushto.c      **** 	OCR1A = 31250;   // timer compare value 1Hz - 31250 
  73               		.loc 1 41 0
  74 004a 22E1      		ldi r18,lo8(18)
  75 004c 3AE7      		ldi r19,lo8(122)
  76 004e 3BBD      		out 0x2a+1,r19
  77 0050 2ABD      		out 0x2a,r18
  42:Pushto.c      **** 	TIMSK|=(1<<OCIE1A); //enable compare reg A interrupt
  78               		.loc 1 42 0
  79 0052 99B7      		in r25,0x39
  80 0054 9061      		ori r25,lo8(16)
  81 0056 99BF      		out 0x39,r25
  43:Pushto.c      **** 	
  44:Pushto.c      ****     	sei(); // enable global interrupts
  82               		.loc 1 44 0
  83               	/* #APP */
  84               	 ;  44 "Pushto.c" 1
  85 0058 7894      		sei
  86               	 ;  0 "" 2
  45:Pushto.c      **** 
  46:Pushto.c      ****     	//dioda -test
  47:Pushto.c      ****     	DDRC = 0xFF;
  87               		.loc 1 47 0
  88               	/* #NOAPP */
  89 005a 84BB      		out 0x14,r24
  48:Pushto.c      ****     	PORTC = 0xFF;
  90               		.loc 1 48 0
  91 005c 85BB      		out 0x15,r24
  92 005e 0895      		ret
  93               		.cfi_endproc
  94               	.LFE7:
  96               	.global	__vector_6
  98               	__vector_6:
  99               	.LFB8:
  49:Pushto.c      ****     	/*  test
  50:Pushto.c      ****     	char buf1[20];
  51:Pushto.c      ****     	sscanf(buf1,"ala ma kota"); // dziala, moze byc uzywane
  52:Pushto.c      ****     	*/
  53:Pushto.c      **** }
  54:Pushto.c      **** 
  55:Pushto.c      **** ISR(TIMER1_COMPA_vect) //obsluga przerwania dla timera
  56:Pushto.c      **** {
 100               		.loc 1 56 0
 101               		.cfi_startproc
 102 0060 1F92      		push r1
 103               	.LCFI0:
 104               		.cfi_def_cfa_offset 3
 105               		.cfi_offset 1, -2
 106 0062 0F92      		push r0
 107               	.LCFI1:
 108               		.cfi_def_cfa_offset 4
 109               		.cfi_offset 0, -3
 110 0064 0FB6      		in r0,__SREG__
 111 0066 0F92      		push r0
 112 0068 1124      		clr __zero_reg__
 113               	/* prologue: Signal */
 114               	/* frame size = 0 */
 115               	/* stack size = 3 */
 116               	.L__stack_usage = 3
 117               	/* epilogue start */
  57:Pushto.c      **** 
  58:Pushto.c      **** }
 118               		.loc 1 58 0
 119 006a 0F90      		pop r0
 120 006c 0FBE      		out __SREG__,r0
 121 006e 0F90      		pop r0
 122 0070 1F90      		pop r1
 123 0072 1895      		reti
 124               		.cfi_endproc
 125               	.LFE8:
 127               	.global	__vector_1
 129               	__vector_1:
 130               	.LFB9:
  59:Pushto.c      **** 
  60:Pushto.c      **** ISR(INT0_vect) //przerwanie dla INT0 dla encodera1
  61:Pushto.c      **** {
 131               		.loc 1 61 0
 132               		.cfi_startproc
 133 0074 1F92      		push r1
 134               	.LCFI2:
 135               		.cfi_def_cfa_offset 3
 136               		.cfi_offset 1, -2
 137 0076 0F92      		push r0
 138               	.LCFI3:
 139               		.cfi_def_cfa_offset 4
 140               		.cfi_offset 0, -3
 141 0078 0FB6      		in r0,__SREG__
 142 007a 0F92      		push r0
 143 007c 1124      		clr __zero_reg__
 144 007e 2F93      		push r18
 145               	.LCFI4:
 146               		.cfi_def_cfa_offset 5
 147               		.cfi_offset 18, -4
 148 0080 3F93      		push r19
 149               	.LCFI5:
 150               		.cfi_def_cfa_offset 6
 151               		.cfi_offset 19, -5
 152 0082 4F93      		push r20
 153               	.LCFI6:
 154               		.cfi_def_cfa_offset 7
 155               		.cfi_offset 20, -6
 156 0084 5F93      		push r21
 157               	.LCFI7:
 158               		.cfi_def_cfa_offset 8
 159               		.cfi_offset 21, -7
 160 0086 6F93      		push r22
 161               	.LCFI8:
 162               		.cfi_def_cfa_offset 9
 163               		.cfi_offset 22, -8
 164 0088 7F93      		push r23
 165               	.LCFI9:
 166               		.cfi_def_cfa_offset 10
 167               		.cfi_offset 23, -9
 168 008a 8F93      		push r24
 169               	.LCFI10:
 170               		.cfi_def_cfa_offset 11
 171               		.cfi_offset 24, -10
 172 008c 9F93      		push r25
 173               	.LCFI11:
 174               		.cfi_def_cfa_offset 12
 175               		.cfi_offset 25, -11
 176 008e AF93      		push r26
 177               	.LCFI12:
 178               		.cfi_def_cfa_offset 13
 179               		.cfi_offset 26, -12
 180 0090 BF93      		push r27
 181               	.LCFI13:
 182               		.cfi_def_cfa_offset 14
 183               		.cfi_offset 27, -13
 184 0092 EF93      		push r30
 185               	.LCFI14:
 186               		.cfi_def_cfa_offset 15
 187               		.cfi_offset 30, -14
 188 0094 FF93      		push r31
 189               	.LCFI15:
 190               		.cfi_def_cfa_offset 16
 191               		.cfi_offset 31, -15
 192               	/* prologue: Signal */
 193               	/* frame size = 0 */
 194               	/* stack size = 15 */
 195               	.L__stack_usage = 15
  62:Pushto.c      **** 	direction(&encoder1);
 196               		.loc 1 62 0
 197 0096 80E0      		ldi r24,lo8(encoder1)
 198 0098 90E0      		ldi r25,hi8(encoder1)
 199 009a 0E94 0000 		call direction
 200               	.LVL0:
 201               	/* epilogue start */
  63:Pushto.c      **** }
 202               		.loc 1 63 0
 203 009e FF91      		pop r31
 204 00a0 EF91      		pop r30
 205 00a2 BF91      		pop r27
 206 00a4 AF91      		pop r26
 207 00a6 9F91      		pop r25
 208 00a8 8F91      		pop r24
 209 00aa 7F91      		pop r23
 210 00ac 6F91      		pop r22
 211 00ae 5F91      		pop r21
 212 00b0 4F91      		pop r20
 213 00b2 3F91      		pop r19
 214 00b4 2F91      		pop r18
 215 00b6 0F90      		pop r0
 216 00b8 0FBE      		out __SREG__,r0
 217 00ba 0F90      		pop r0
 218 00bc 1F90      		pop r1
 219 00be 1895      		reti
 220               		.cfi_endproc
 221               	.LFE9:
 223               	.global	__vector_2
 225               	__vector_2:
 226               	.LFB10:
  64:Pushto.c      **** 
  65:Pushto.c      **** ISR(INT1_vect) //przerwanie dla INT1 dla encodera2
  66:Pushto.c      **** {
 227               		.loc 1 66 0
 228               		.cfi_startproc
 229 00c0 1F92      		push r1
 230               	.LCFI16:
 231               		.cfi_def_cfa_offset 3
 232               		.cfi_offset 1, -2
 233 00c2 0F92      		push r0
 234               	.LCFI17:
 235               		.cfi_def_cfa_offset 4
 236               		.cfi_offset 0, -3
 237 00c4 0FB6      		in r0,__SREG__
 238 00c6 0F92      		push r0
 239 00c8 1124      		clr __zero_reg__
 240 00ca 2F93      		push r18
 241               	.LCFI18:
 242               		.cfi_def_cfa_offset 5
 243               		.cfi_offset 18, -4
 244 00cc 3F93      		push r19
 245               	.LCFI19:
 246               		.cfi_def_cfa_offset 6
 247               		.cfi_offset 19, -5
 248 00ce 4F93      		push r20
 249               	.LCFI20:
 250               		.cfi_def_cfa_offset 7
 251               		.cfi_offset 20, -6
 252 00d0 5F93      		push r21
 253               	.LCFI21:
 254               		.cfi_def_cfa_offset 8
 255               		.cfi_offset 21, -7
 256 00d2 6F93      		push r22
 257               	.LCFI22:
 258               		.cfi_def_cfa_offset 9
 259               		.cfi_offset 22, -8
 260 00d4 7F93      		push r23
 261               	.LCFI23:
 262               		.cfi_def_cfa_offset 10
 263               		.cfi_offset 23, -9
 264 00d6 8F93      		push r24
 265               	.LCFI24:
 266               		.cfi_def_cfa_offset 11
 267               		.cfi_offset 24, -10
 268 00d8 9F93      		push r25
 269               	.LCFI25:
 270               		.cfi_def_cfa_offset 12
 271               		.cfi_offset 25, -11
 272 00da AF93      		push r26
 273               	.LCFI26:
 274               		.cfi_def_cfa_offset 13
 275               		.cfi_offset 26, -12
 276 00dc BF93      		push r27
 277               	.LCFI27:
 278               		.cfi_def_cfa_offset 14
 279               		.cfi_offset 27, -13
 280 00de EF93      		push r30
 281               	.LCFI28:
 282               		.cfi_def_cfa_offset 15
 283               		.cfi_offset 30, -14
 284 00e0 FF93      		push r31
 285               	.LCFI29:
 286               		.cfi_def_cfa_offset 16
 287               		.cfi_offset 31, -15
 288               	/* prologue: Signal */
 289               	/* frame size = 0 */
 290               	/* stack size = 15 */
 291               	.L__stack_usage = 15
  67:Pushto.c      **** 	direction(&encoder2);
 292               		.loc 1 67 0
 293 00e2 80E0      		ldi r24,lo8(encoder2)
 294 00e4 90E0      		ldi r25,hi8(encoder2)
 295 00e6 0E94 0000 		call direction
 296               	.LVL1:
 297               	/* epilogue start */
  68:Pushto.c      **** }
 298               		.loc 1 68 0
 299 00ea FF91      		pop r31
 300 00ec EF91      		pop r30
 301 00ee BF91      		pop r27
 302 00f0 AF91      		pop r26
 303 00f2 9F91      		pop r25
 304 00f4 8F91      		pop r24
 305 00f6 7F91      		pop r23
 306 00f8 6F91      		pop r22
 307 00fa 5F91      		pop r21
 308 00fc 4F91      		pop r20
 309 00fe 3F91      		pop r19
 310 0100 2F91      		pop r18
 311 0102 0F90      		pop r0
 312 0104 0FBE      		out __SREG__,r0
 313 0106 0F90      		pop r0
 314 0108 1F90      		pop r1
 315 010a 1895      		reti
 316               		.cfi_endproc
 317               	.LFE10:
 319               		.section	.rodata.str1.1,"aMS",@progbits,1
 320               	.LC0:
 321 0000 5055 5348 		.string	"PUSHTO"
 321      544F 00
 322               	.LC1:
 323 0007 4531 3D00 		.string	"E1="
 324               	.LC2:
 325 000b 2045 323D 		.string	" E2="
 325      00
 326               		.section	.text.startup,"ax",@progbits
 327               	.global	main
 329               	main:
 330               	.LFB11:
  69:Pushto.c      **** 
  70:Pushto.c      **** 
  71:Pushto.c      **** int main(void)
  72:Pushto.c      **** {
 331               		.loc 1 72 0
 332               		.cfi_startproc
 333               	/* prologue: function */
 334               	/* frame size = 0 */
 335               	/* stack size = 0 */
 336               	.L__stack_usage = 0
  73:Pushto.c      **** 
  74:Pushto.c      **** 	system_init();
 337               		.loc 1 74 0
 338 0000 0E94 0000 		call system_init
 339               	.LVL2:
  75:Pushto.c      **** 	lcdInit();
 340               		.loc 1 75 0
 341 0004 0E94 0000 		call lcdInit
 342               	.LVL3:
  76:Pushto.c      **** 	prints("PUSHTO");
 343               		.loc 1 76 0
 344 0008 80E0      		ldi r24,lo8(.LC0)
 345 000a 90E0      		ldi r25,hi8(.LC0)
 346 000c 0E94 0000 		call prints
 347               	.LVL4:
 348               	.L6:
  77:Pushto.c      **** 	while(1)
  78:Pushto.c      **** 	{
  79:Pushto.c      **** 
  80:Pushto.c      **** 		
  81:Pushto.c      **** 		gotoXy(0,0);
 349               		.loc 1 81 0 discriminator 1
 350 0010 60E0      		ldi r22,0
 351 0012 80E0      		ldi r24,0
 352 0014 0E94 0000 		call gotoXy
 353               	.LVL5:
  82:Pushto.c      **** 		prints("E1=");
 354               		.loc 1 82 0 discriminator 1
 355 0018 80E0      		ldi r24,lo8(.LC1)
 356 001a 90E0      		ldi r25,hi8(.LC1)
 357 001c 0E94 0000 		call prints
 358               	.LVL6:
  83:Pushto.c      **** 		integerToLcd(encoder1.count);
 359               		.loc 1 83 0 discriminator 1
 360 0020 8091 0000 		lds r24,encoder1+2
 361 0024 9091 0000 		lds r25,encoder1+2+1
 362 0028 0E94 0000 		call integerToLcd
 363               	.LVL7:
  84:Pushto.c      **** 		prints(" E2=");
 364               		.loc 1 84 0 discriminator 1
 365 002c 80E0      		ldi r24,lo8(.LC2)
 366 002e 90E0      		ldi r25,hi8(.LC2)
 367 0030 0E94 0000 		call prints
 368               	.LVL8:
  85:Pushto.c      **** 		integerToLcd(encoder2.count);
 369               		.loc 1 85 0 discriminator 1
 370 0034 8091 0000 		lds r24,encoder2+2
 371 0038 9091 0000 		lds r25,encoder2+2+1
 372 003c 0E94 0000 		call integerToLcd
 373               	.LVL9:
  86:Pushto.c      **** 		gotoXy(0,1);
 374               		.loc 1 86 0 discriminator 1
 375 0040 61E0      		ldi r22,lo8(1)
 376 0042 80E0      		ldi r24,0
 377 0044 0E94 0000 		call gotoXy
 378               	.LVL10:
  87:Pushto.c      **** 
  88:Pushto.c      **** 		integerToLcd(keypad(&keypad_A));
 379               		.loc 1 88 0 discriminator 1
 380 0048 80E0      		ldi r24,lo8(keypad_A)
 381 004a 90E0      		ldi r25,hi8(keypad_A)
 382 004c 0E94 0000 		call keypad
 383               	.LVL11:
 384 0050 90E0      		ldi r25,0
 385 0052 0E94 0000 		call integerToLcd
 386               	.LVL12:
  89:Pushto.c      **** 		/*
  90:Pushto.c      **** 
  91:Pushto.c      **** 		if(keypad() == 1)
  92:Pushto.c      **** 		{
  93:Pushto.c      **** 			PORTC ^= (1 << 0); 
  94:Pushto.c      **** 		}
  95:Pushto.c      **** 
  96:Pushto.c      **** 		if(!(0xFF & (keypad(&keypad_A)) == 0xFF))  //odczyt klawiatury
  97:Pushto.c      **** 			PORTC ^= (1 << 0); // potwierdzenie odczytu - test
  98:Pushto.c      **** 
  99:Pushto.c      **** 		keypad_proc(&keypad_A); //przetwarzanie znakow
 100:Pushto.c      **** 
 101:Pushto.c      **** 		gotoXy(0,0);
 102:Pushto.c      **** 		if(keypad_A.flags & KB_NEW)
 103:Pushto.c      **** 		{
 104:Pushto.c      **** 			prints("nowy obiekt");
 105:Pushto.c      **** 			keypad_A.flags &= ~KB_NEW;
 106:Pushto.c      **** 		}
 107:Pushto.c      **** 		gotoXy(0,0);
 108:Pushto.c      **** 		if(keypad_A.flags & KB_CAL)
 109:Pushto.c      **** 		{
 110:Pushto.c      **** 			prints("kalibracja ");
 111:Pushto.c      **** 			keypad_A.flags &= ~KB_CAL;
 112:Pushto.c      **** 		}
 113:Pushto.c      **** 		gotoXy(0,1);
 114:Pushto.c      **** 		prints(keypad_A.buf[0]);
 115:Pushto.c      **** 
 116:Pushto.c      **** 		if(keypad_A.i > 14)
 117:Pushto.c      **** 			keypad_A.i=0;
 118:Pushto.c      **** */
 119:Pushto.c      **** 	}
 387               		.loc 1 119 0 discriminator 1
 388 0056 00C0      		rjmp .L6
 389               		.cfi_endproc
 390               	.LFE11:
 392               		.comm	keypad_A,20,1
 393               		.comm	encoder2,4,1
 394               		.comm	encoder1,4,1
 395               		.text
 396               	.Letext0:
 397               		.file 2 "/usr/lib/avr/include/stdint.h"
 398               		.file 3 "encoder.h"
 399               		.file 4 "keypad.h"
 400               		.file 5 "lcd.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Pushto.c
     /tmp/cc3uQS6W.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc3uQS6W.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc3uQS6W.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc3uQS6W.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc3uQS6W.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc3uQS6W.s:12     .text:0000000000000000 system_init
                            *COM*:0000000000000004 encoder1
                            *COM*:0000000000000004 encoder2
                            *COM*:0000000000000014 keypad_A
     /tmp/cc3uQS6W.s:98     .text:0000000000000060 __vector_6
     /tmp/cc3uQS6W.s:129    .text:0000000000000074 __vector_1
     /tmp/cc3uQS6W.s:225    .text:00000000000000c0 __vector_2
     /tmp/cc3uQS6W.s:329    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
direction
lcdInit
prints
gotoXy
integerToLcd
keypad
__do_copy_data
__do_clear_bss
