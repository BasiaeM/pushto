   1               		.file	"Pushto.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	system_init
  12               	system_init:
  13               	.LFB7:
  14               		.file 1 "Pushto.c"
   1:Pushto.c      **** #include <avr/io.h>
   2:Pushto.c      **** #include <stdio.h>
   3:Pushto.c      **** 
   4:Pushto.c      **** #define F_CPU 2000000UL //kwarc 2MHz
   5:Pushto.c      **** #include <util/delay.h>
   6:Pushto.c      **** #include <avr/interrupt.h>
   7:Pushto.c      **** #include "lcd.h"
   8:Pushto.c      **** //#include "encoder.h"
   9:Pushto.c      **** #include "keypad.h"
  10:Pushto.c      **** #include "pushto_lib.h"
  11:Pushto.c      ****     
  12:Pushto.c      **** 
  13:Pushto.c      **** void system_init (void)
  14:Pushto.c      **** {	
  15               		.loc 1 14 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  15:Pushto.c      **** 	/*Inicjalizacja przerwa≈Ñ zewnetrznych*/
  16:Pushto.c      **** 	MCUCR |=(1<<ISC00) | (1<<ISC10);	//ustawienie przerwan na zmiane na INT0 i INT1
  21               		.loc 1 16 0
  22 0000 85B7      		in r24,0x35
  23 0002 8560      		ori r24,lo8(5)
  24 0004 85BF      		out 0x35,r24
  17:Pushto.c      **** 	GICR |= (1<<INT0) | (1<<INT1); //wlaczenie zewnetrznych przerwan na INT0 i INT1
  25               		.loc 1 17 0
  26 0006 8BB7      		in r24,0x3b
  27 0008 806C      		ori r24,lo8(-64)
  28 000a 8BBF      		out 0x3b,r24
  18:Pushto.c      **** 	
  19:Pushto.c      **** 	/*inicjalizacja LCD*/
  20:Pushto.c      **** 	LCD_DIR = 0xFF;		//Ustawienie pinow dla wyswietlacza LCD
  29               		.loc 1 20 0
  30 000c 8FEF      		ldi r24,lo8(-1)
  31 000e 8ABB      		out 0x1a,r24
  21:Pushto.c      **** 
  22:Pushto.c      **** 	/*inicjalizacja encoderow*/
  23:Pushto.c      **** 	/*EN_DIR = 0b00000000; //Ustawienie pinow dla encoderow
  24:Pushto.c      **** 	EN_PORT = 0b00001111; //pullupy dla encoderow
  25:Pushto.c      **** 
  26:Pushto.c      **** 	encoder1.maskA=0b00000100;
  27:Pushto.c      **** 	encoder1.maskB=0b00000001;
  28:Pushto.c      **** 	encoder1.count=0; //----------------------------enkodery start 0 
  29:Pushto.c      **** 	encoder2.maskA=0b000001000;
  30:Pushto.c      **** 	encoder2.maskB=0b000000010;
  31:Pushto.c      **** 	encoder2.count=0;*/
  32:Pushto.c      **** 
  33:Pushto.c      **** 	//inicjalizacja klawiatury
  34:Pushto.c      **** 	keypad_A.i=0; //zerowanie wskaznika buforu
  32               		.loc 1 34 0
  33 0010 E0E0      		ldi r30,lo8(keypad_A)
  34 0012 F0E0      		ldi r31,hi8(keypad_A)
  35 0014 138A      		std Z+19,__zero_reg__
  36 0016 128A      		std Z+18,__zero_reg__
  35:Pushto.c      **** 	keypad_A.flags='\0';
  37               		.loc 1 35 0
  38 0018 148A      		std Z+20,__zero_reg__
  36:Pushto.c      **** 	keypad_A.last_result = 0xFF;
  39               		.loc 1 36 0
  40 001a 8183      		std Z+1,r24
  37:Pushto.c      **** 
  38:Pushto.c      **** 	telescope_A.update=0; //flaga aktualizacja nastaw
  41               		.loc 1 38 0
  42 001c 1092 0000 		sts telescope_A+2+1,__zero_reg__
  43 0020 1092 0000 		sts telescope_A+2,__zero_reg__
  39:Pushto.c      **** 
  40:Pushto.c      **** 	//############# Timer1 16bit config ####################
  41:Pushto.c      **** 	TCCR1A |= 0;   // not required since WGM11:0, both are zero (0)
  44               		.loc 1 41 0
  45 0024 9FB5      		in r25,0x2f
  46 0026 9FBD      		out 0x2f,r25
  42:Pushto.c      ****  	TCCR1B |= (1 << WGM12)|(1 << CS11)|(1 << CS10);   // Mode = CTC, Prescaler = 64
  47               		.loc 1 42 0
  48 0028 9EB5      		in r25,0x2e
  49 002a 9B60      		ori r25,lo8(11)
  50 002c 9EBD      		out 0x2e,r25
  43:Pushto.c      **** 	OCR1A = 31250;   // timer compare value 1Hz - 31250 
  51               		.loc 1 43 0
  52 002e 22E1      		ldi r18,lo8(18)
  53 0030 3AE7      		ldi r19,lo8(122)
  54 0032 3BBD      		out 0x2a+1,r19
  55 0034 2ABD      		out 0x2a,r18
  44:Pushto.c      **** 	TIMSK|=(1<<OCIE1A); //enable compare reg A interrupt
  56               		.loc 1 44 0
  57 0036 99B7      		in r25,0x39
  58 0038 9061      		ori r25,lo8(16)
  59 003a 99BF      		out 0x39,r25
  45:Pushto.c      **** 	
  46:Pushto.c      ****     	sei(); // enable global interrupts
  60               		.loc 1 46 0
  61               	/* #APP */
  62               	 ;  46 "Pushto.c" 1
  63 003c 7894      		sei
  64               	 ;  0 "" 2
  47:Pushto.c      **** 
  48:Pushto.c      ****     	//dioda -test
  49:Pushto.c      ****     	DDRC = 0xFF;
  65               		.loc 1 49 0
  66               	/* #NOAPP */
  67 003e 84BB      		out 0x14,r24
  50:Pushto.c      ****     	PORTC = 0xFF;
  68               		.loc 1 50 0
  69 0040 85BB      		out 0x15,r24
  70 0042 0895      		ret
  71               		.cfi_endproc
  72               	.LFE7:
  74               	.global	__vector_6
  76               	__vector_6:
  77               	.LFB8:
  51:Pushto.c      ****     	/*  test
  52:Pushto.c      ****     	char buf1[20];
  53:Pushto.c      ****     	sscanf(buf1,"ala ma kota"); // dziala, moze byc uzywane
  54:Pushto.c      ****     	*/
  55:Pushto.c      **** }
  56:Pushto.c      **** 
  57:Pushto.c      **** ISR(TIMER1_COMPA_vect) //obsluga przerwania dla timera
  58:Pushto.c      **** {
  78               		.loc 1 58 0
  79               		.cfi_startproc
  80 0044 1F92      		push r1
  81               	.LCFI0:
  82               		.cfi_def_cfa_offset 3
  83               		.cfi_offset 1, -2
  84 0046 0F92      		push r0
  85               	.LCFI1:
  86               		.cfi_def_cfa_offset 4
  87               		.cfi_offset 0, -3
  88 0048 0FB6      		in r0,__SREG__
  89 004a 0F92      		push r0
  90 004c 1124      		clr __zero_reg__
  91 004e 5F93      		push r21
  92               	.LCFI2:
  93               		.cfi_def_cfa_offset 5
  94               		.cfi_offset 21, -4
  95 0050 6F93      		push r22
  96               	.LCFI3:
  97               		.cfi_def_cfa_offset 6
  98               		.cfi_offset 22, -5
  99 0052 7F93      		push r23
 100               	.LCFI4:
 101               		.cfi_def_cfa_offset 7
 102               		.cfi_offset 23, -6
 103 0054 8F93      		push r24
 104               	.LCFI5:
 105               		.cfi_def_cfa_offset 8
 106               		.cfi_offset 24, -7
 107 0056 9F93      		push r25
 108               	.LCFI6:
 109               		.cfi_def_cfa_offset 9
 110               		.cfi_offset 25, -8
 111 0058 AF93      		push r26
 112               	.LCFI7:
 113               		.cfi_def_cfa_offset 10
 114               		.cfi_offset 26, -9
 115 005a BF93      		push r27
 116               	.LCFI8:
 117               		.cfi_def_cfa_offset 11
 118               		.cfi_offset 27, -10
 119               	/* prologue: Signal */
 120               	/* frame size = 0 */
 121               	/* stack size = 10 */
 122               	.L__stack_usage = 10
  59:Pushto.c      **** 	telescope_A.time++; //czas od kalibracji w sekundachs
 123               		.loc 1 59 0
 124 005c 8091 0000 		lds r24,telescope_A
 125 0060 9091 0000 		lds r25,telescope_A+1
 126 0064 0196      		adiw r24,1
 127 0066 9093 0000 		sts telescope_A+1,r25
 128 006a 8093 0000 		sts telescope_A,r24
  60:Pushto.c      **** 	if(telescope_A.time%10==0)
 129               		.loc 1 60 0
 130 006e 6AE0      		ldi r22,lo8(10)
 131 0070 70E0      		ldi r23,0
 132 0072 0E94 0000 		call __divmodhi4
 133 0076 892B      		or r24,r25
 134 0078 01F4      		brne .L2
  61:Pushto.c      **** 		telescope_A.update=1;
 135               		.loc 1 61 0
 136 007a 81E0      		ldi r24,lo8(1)
 137 007c 90E0      		ldi r25,0
 138 007e 9093 0000 		sts telescope_A+2+1,r25
 139 0082 8093 0000 		sts telescope_A+2,r24
 140               	.L2:
 141               	/* epilogue start */
  62:Pushto.c      **** }
 142               		.loc 1 62 0
 143 0086 BF91      		pop r27
 144 0088 AF91      		pop r26
 145 008a 9F91      		pop r25
 146 008c 8F91      		pop r24
 147 008e 7F91      		pop r23
 148 0090 6F91      		pop r22
 149 0092 5F91      		pop r21
 150 0094 0F90      		pop r0
 151 0096 0FBE      		out __SREG__,r0
 152 0098 0F90      		pop r0
 153 009a 1F90      		pop r1
 154 009c 1895      		reti
 155               		.cfi_endproc
 156               	.LFE8:
 158               	.global	__vector_1
 160               	__vector_1:
 161               	.LFB9:
  63:Pushto.c      **** 
  64:Pushto.c      **** ISR(INT0_vect) //przerwanie dla INT0 dla encodera1
  65:Pushto.c      **** {
 162               		.loc 1 65 0
 163               		.cfi_startproc
 164 009e 1F92      		push r1
 165               	.LCFI9:
 166               		.cfi_def_cfa_offset 3
 167               		.cfi_offset 1, -2
 168 00a0 0F92      		push r0
 169               	.LCFI10:
 170               		.cfi_def_cfa_offset 4
 171               		.cfi_offset 0, -3
 172 00a2 0FB6      		in r0,__SREG__
 173 00a4 0F92      		push r0
 174 00a6 1124      		clr __zero_reg__
 175               	/* prologue: Signal */
 176               	/* frame size = 0 */
 177               	/* stack size = 3 */
 178               	.L__stack_usage = 3
 179               	/* epilogue start */
  66:Pushto.c      **** 	//direction(&encoder1);
  67:Pushto.c      **** }
 180               		.loc 1 67 0
 181 00a8 0F90      		pop r0
 182 00aa 0FBE      		out __SREG__,r0
 183 00ac 0F90      		pop r0
 184 00ae 1F90      		pop r1
 185 00b0 1895      		reti
 186               		.cfi_endproc
 187               	.LFE9:
 189               	.global	__vector_2
 191               	__vector_2:
 192               	.LFB10:
  68:Pushto.c      **** 
  69:Pushto.c      **** ISR(INT1_vect) //przerwanie dla INT1 dla encodera2
  70:Pushto.c      **** {
 193               		.loc 1 70 0
 194               		.cfi_startproc
 195 00b2 1F92      		push r1
 196               	.LCFI11:
 197               		.cfi_def_cfa_offset 3
 198               		.cfi_offset 1, -2
 199 00b4 0F92      		push r0
 200               	.LCFI12:
 201               		.cfi_def_cfa_offset 4
 202               		.cfi_offset 0, -3
 203 00b6 0FB6      		in r0,__SREG__
 204 00b8 0F92      		push r0
 205 00ba 1124      		clr __zero_reg__
 206               	/* prologue: Signal */
 207               	/* frame size = 0 */
 208               	/* stack size = 3 */
 209               	.L__stack_usage = 3
 210               	/* epilogue start */
  71:Pushto.c      **** 	//direction(&encoder2);
  72:Pushto.c      **** }
 211               		.loc 1 72 0
 212 00bc 0F90      		pop r0
 213 00be 0FBE      		out __SREG__,r0
 214 00c0 0F90      		pop r0
 215 00c2 1F90      		pop r1
 216 00c4 1895      		reti
 217               		.cfi_endproc
 218               	.LFE10:
 220               		.section	.text.startup,"ax",@progbits
 221               	.global	main
 223               	main:
 224               	.LFB11:
  73:Pushto.c      **** 
  74:Pushto.c      **** 
  75:Pushto.c      **** int main(void)
  76:Pushto.c      **** {
 225               		.loc 1 76 0
 226               		.cfi_startproc
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 0 */
 230               	.L__stack_usage = 0
  77:Pushto.c      **** 	system_init();
 231               		.loc 1 77 0
 232 0000 0E94 0000 		call system_init
 233               	.LVL0:
  78:Pushto.c      **** 	lcdInit();
 234               		.loc 1 78 0
 235 0004 0E94 0000 		call lcdInit
 236               	.LVL1:
 237               	.L12:
  79:Pushto.c      **** 	char buf[20];
  80:Pushto.c      **** 	float a=10.1234;
  81:Pushto.c      **** 	//prints("PUSHTO");
  82:Pushto.c      **** 	while(1)
  83:Pushto.c      **** 	{
  84:Pushto.c      **** 
  85:Pushto.c      **** 		
  86:Pushto.c      **** 		/*gotoXy(0,0);
  87:Pushto.c      **** 		prints("E1=");
  88:Pushto.c      **** 		integerToLcd(encoder1.count);
  89:Pushto.c      **** 		prints(" E2=");
  90:Pushto.c      **** 		integerToLcd(encoder2.count);
  91:Pushto.c      **** 		
  92:Pushto.c      **** 		
  93:Pushto.c      **** 		gotoXy(8,0);
  94:Pushto.c      **** 		integerToLcd(zeg);
  95:Pushto.c      **** 		gotoXy(0,1);
  96:Pushto.c      **** 		integerToLcd(keypad(&keypad_A));
  97:Pushto.c      **** 
  98:Pushto.c      **** 		if (keypad_A.result==0b11100111)
  99:Pushto.c      **** 			zeg=0x00;
 100:Pushto.c      **** 	
 101:Pushto.c      **** 
 102:Pushto.c      **** 		if(keypad() == 1)
 103:Pushto.c      **** 		{
 104:Pushto.c      **** 			PORTC ^= (1 << 0); 
 105:Pushto.c      **** 		}
 106:Pushto.c      **** */
 107:Pushto.c      **** 		keypad(&keypad_A); //odczyt klawiatury
 238               		.loc 1 107 0
 239 0008 80E0      		ldi r24,lo8(keypad_A)
 240 000a 90E0      		ldi r25,hi8(keypad_A)
 241 000c 0E94 0000 		call keypad
 242               	.LVL2:
 108:Pushto.c      **** 		keypad_proc(&keypad_A); //przetwarzanie znakow
 243               		.loc 1 108 0
 244 0010 80E0      		ldi r24,lo8(keypad_A)
 245 0012 90E0      		ldi r25,hi8(keypad_A)
 246 0014 0E94 0000 		call keypad_proc
 247               	.LVL3:
 109:Pushto.c      **** 
 110:Pushto.c      **** 		if(keypad_A.flags & KB_NEW)
 248               		.loc 1 110 0
 249 0018 8091 0000 		lds r24,keypad_A+20
 250 001c 86FF      		sbrs r24,6
 251 001e 00C0      		rjmp .L8
 111:Pushto.c      **** 		{
 112:Pushto.c      **** 			nowy_cel(&keypad_A,&telescope_A);
 252               		.loc 1 112 0
 253 0020 60E0      		ldi r22,lo8(telescope_A)
 254 0022 70E0      		ldi r23,hi8(telescope_A)
 255 0024 80E0      		ldi r24,lo8(keypad_A)
 256 0026 90E0      		ldi r25,hi8(keypad_A)
 257 0028 0E94 0000 		call nowy_cel
 258               	.LVL4:
 113:Pushto.c      **** 			keypad_A.flags &= ~KB_NEW;
 259               		.loc 1 113 0
 260 002c 8091 0000 		lds r24,keypad_A+20
 261 0030 8F7B      		andi r24,lo8(-65)
 262 0032 8093 0000 		sts keypad_A+20,r24
 263               	.L8:
 114:Pushto.c      **** 		}
 115:Pushto.c      **** 		if(keypad_A.flags & KB_CAL)
 264               		.loc 1 115 0
 265 0036 8091 0000 		lds r24,keypad_A+20
 266 003a 85FF      		sbrs r24,5
 267 003c 00C0      		rjmp .L9
 116:Pushto.c      **** 		{
 117:Pushto.c      **** 			kalibracja(&encoder1,&encoder2,&telescope_A); // funkcja z pushto_lib
 268               		.loc 1 117 0
 269 003e 40E0      		ldi r20,lo8(telescope_A)
 270 0040 50E0      		ldi r21,hi8(telescope_A)
 271 0042 60E0      		ldi r22,lo8(encoder2)
 272 0044 70E0      		ldi r23,hi8(encoder2)
 273 0046 80E0      		ldi r24,lo8(encoder1)
 274 0048 90E0      		ldi r25,hi8(encoder1)
 275 004a 0E94 0000 		call kalibracja
 276               	.LVL5:
 118:Pushto.c      **** 			keypad_A.flags &= ~KB_CAL;
 277               		.loc 1 118 0
 278 004e 8091 0000 		lds r24,keypad_A+20
 279 0052 8F7D      		andi r24,lo8(-33)
 280 0054 8093 0000 		sts keypad_A+20,r24
 281               	.L9:
 119:Pushto.c      **** 		}
 120:Pushto.c      **** 		if(keypad_A.flags & KB_CLR)
 282               		.loc 1 120 0
 283 0058 8091 0000 		lds r24,keypad_A+20
 284 005c 84FF      		sbrs r24,4
 285 005e 00C0      		rjmp .L10
 121:Pushto.c      **** 		{
 122:Pushto.c      **** 			lcd_clr();
 286               		.loc 1 122 0
 287 0060 0E94 0000 		call lcd_clr
 288               	.LVL6:
 123:Pushto.c      **** 			keypad_A.flags &= ~KB_CLR;
 289               		.loc 1 123 0
 290 0064 8091 0000 		lds r24,keypad_A+20
 291 0068 8F7E      		andi r24,lo8(-17)
 292 006a 8093 0000 		sts keypad_A+20,r24
 293               	.L10:
 124:Pushto.c      **** 		}
 125:Pushto.c      **** 		if(telescope_A.update)
 294               		.loc 1 125 0
 295 006e 8091 0000 		lds r24,telescope_A+2
 296 0072 9091 0000 		lds r25,telescope_A+2+1
 297 0076 892B      		or r24,r25
 298 0078 01F0      		breq .L11
 126:Pushto.c      **** 		{
 127:Pushto.c      **** 			obliczenie_nastaw(&telescope_A); //funkcja na obliczenie nastaw, co 10sek (patrz ISR(TIMER1_COMP
 299               		.loc 1 127 0
 300 007a 80E0      		ldi r24,lo8(telescope_A)
 301 007c 90E0      		ldi r25,hi8(telescope_A)
 302 007e 0E94 0000 		call obliczenie_nastaw
 303               	.LVL7:
 304               	.L11:
 128:Pushto.c      **** 		}
 129:Pushto.c      **** 
 130:Pushto.c      **** 		
 131:Pushto.c      **** 		//sprintf(buf,"%f",a);
 132:Pushto.c      **** 		//prints(buf);
 133:Pushto.c      **** 		//integerToLcd(telescope_A.obr_zad);
 134:Pushto.c      **** 		//gotoXy(0,1);
 135:Pushto.c      **** 		//sprintf(buf,"%f",telescope_A.obr_zad);
 136:Pushto.c      **** 		//integerToLcd(telescope_A.obr_zad);
 137:Pushto.c      **** 
 138:Pushto.c      **** 		if(keypad_A.i > 14)
 305               		.loc 1 138 0
 306 0082 8091 0000 		lds r24,keypad_A+18
 307 0086 9091 0000 		lds r25,keypad_A+18+1
 308 008a 0F97      		sbiw r24,15
 309 008c 04F4      		brge .+2
 310 008e 00C0      		rjmp .L12
 139:Pushto.c      **** 			keypad_A.i=0;
 311               		.loc 1 139 0
 312 0090 1092 0000 		sts keypad_A+18+1,__zero_reg__
 313 0094 1092 0000 		sts keypad_A+18,__zero_reg__
 314 0098 00C0      		rjmp .L12
 315               		.cfi_endproc
 316               	.LFE11:
 318               		.comm	telescope_A,24,1
 319               		.comm	encoder2,4,1
 320               		.comm	encoder1,4,1
 321               		.comm	keypad_A,21,1
 322               		.text
 323               	.Letext0:
 324               		.file 2 "/usr/lib/avr/include/stdint.h"
 325               		.file 3 "keypad.h"
 326               		.file 4 "encoder.h"
 327               		.file 5 "pushto_lib.h"
 328               		.file 6 "lcd.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Pushto.c
     /tmp/ccOArmqT.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccOArmqT.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccOArmqT.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccOArmqT.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccOArmqT.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccOArmqT.s:12     .text:0000000000000000 system_init
                            *COM*:0000000000000015 keypad_A
                            *COM*:0000000000000018 telescope_A
     /tmp/ccOArmqT.s:76     .text:0000000000000044 __vector_6
     /tmp/ccOArmqT.s:160    .text:000000000000009e __vector_1
     /tmp/ccOArmqT.s:191    .text:00000000000000b2 __vector_2
     /tmp/ccOArmqT.s:223    .text.startup:0000000000000000 main
                            *COM*:0000000000000004 encoder2
                            *COM*:0000000000000004 encoder1

UNDEFINED SYMBOLS
__divmodhi4
lcdInit
keypad
keypad_proc
nowy_cel
kalibracja
lcd_clr
obliczenie_nastaw
__do_clear_bss
